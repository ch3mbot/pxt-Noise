{"entries":[{"timestamp":1743053828146,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":234,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</variable><variable id=\"spI`B?ML_K@WF]ppXSF:\">i</variable><variable id=\"y$KNNzp3?jgee^^w?~4g\">j</variable></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"variables_set\"><field name=\"VAR\" id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"image_create\"><value name=\"width\"><shadow type=\"math_number\"><field name=\"NUM\">160</field></shadow></value><value name=\"height\"><shadow type=\"math_number\"><field name=\"NUM\">120</field></shadow></value></block></value><next><block type=\"gamesetbackgroundimage\"><value name=\"img\"><shadow type=\"background_image_picker\"><field name=\"img\"></field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</field></block></value><next><block type=\"pxt_controls_for\"><value name=\"VAR\"><block type=\"variables_get_reporter\"><mutation duplicateondrag=\"true\"></mutation><field name=\"VAR\" id=\"spI`B?ML_K@WF]ppXSF:\">i</field></block></value><value name=\"TO\"><shadow type=\"math_whole_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_number\"><field name=\"NUM\">159</field></block></value><statement name=\"DO\"><block type=\"pxt_controls_for\"><value name=\"VAR\"><block type=\"variables_get_reporter\"><mutation duplicateondrag=\"true\"></mutation><field name=\"VAR\" id=\"y$KNNzp3?jgee^^w?~4g\">j</field></block></value><value name=\"TO\"><shadow type=\"math_whole_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_number\"><field name=\"NUM\">119</field></block></value><statement name=\"DO\"><block type=\"controls_if\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\"><field name=\"OP\">EQ</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_modulo\"><value name=\"DIVIDEND\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"spI`B?ML_K@WF]ppXSF:\">i</field></block></value><value name=\"DIVISOR\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_modulo\"><value name=\"DIVIDEND\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"y$KNNzp3?jgee^^w?~4g\">j</field></block></value><value name=\"DIVISOR\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value></block></value></block></value><statement name=\"DO0\"><block type=\"Image_setPixel\"><value name=\"picture\"><block type=\"variables_get\"><field name=\"VAR\" id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</field></block></value><value name=\"x\"><block type=\"variables_get\"><field name=\"VAR\" id=\"spI`B?ML_K@WF]ppXSF:\">i</field></block></value><value name=\"y\"><block type=\"variables_get\"><field name=\"VAR\" id=\"y$KNNzp3?jgee^^w?~4g\">j</field></block></value><value name=\"c\"><shadow type=\"colorindexpicker\"><field name=\"index\">1</field></shadow></value></block></statement><statement name=\"ELSE\"><block type=\"Image_setPixel\"><value name=\"picture\"><block type=\"variables_get\"><field name=\"VAR\" id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</field></block></value><value name=\"x\"><block type=\"variables_get\"><field name=\"VAR\" id=\"spI`B?ML_K@WF]ppXSF:\">i</field></block></value><value name=\"y\"><block type=\"variables_get\"><field name=\"VAR\" id=\"y$KNNzp3?jgee^^w?~4g\">j</field></block></value><value name=\"c\"><shadow type=\"colorindexpicker\"><field name=\"index\">15</field></shadow></value></block></statement></block></statement></block></statement><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Simplex noise test...</field></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let simpGen = new noise.OpenSimplexNoise2D();\" numlines=\"1\" declaredvars=\"simpGen\"></mutation><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">160</field></shadow></value><statement name=\"DO\"><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">120</field></shadow></value></block></statement></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":306,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1743053828145,"editorVersion":"2.0.40","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</variable><variable id=\"spI`B?ML_K@WF]ppXSF:\">i</variable><variable id=\"y$KNNzp3?jgee^^w?~4g\">j</variable></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"variables_set\"><field name=\"VAR\" id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"image_create\"><value name=\"width\"><shadow type=\"math_number\"><field name=\"NUM\">160</field></shadow></value><value name=\"height\"><shadow type=\"math_number\"><field name=\"NUM\">120</field></shadow></value></block></value><next><block type=\"gamesetbackgroundimage\"><value name=\"img\"><shadow type=\"background_image_picker\"><field name=\"img\"></field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</field></block></value><next><block type=\"pxt_controls_for\"><value name=\"VAR\"><block type=\"variables_get_reporter\"><mutation duplicateondrag=\"true\"></mutation><field name=\"VAR\" id=\"spI`B?ML_K@WF]ppXSF:\">i</field></block></value><value name=\"TO\"><shadow type=\"math_whole_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_number\"><field name=\"NUM\">159</field></block></value><statement name=\"DO\"><block type=\"pxt_controls_for\"><value name=\"VAR\"><block type=\"variables_get_reporter\"><mutation duplicateondrag=\"true\"></mutation><field name=\"VAR\" id=\"y$KNNzp3?jgee^^w?~4g\">j</field></block></value><value name=\"TO\"><shadow type=\"math_whole_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_number\"><field name=\"NUM\">119</field></block></value><statement name=\"DO\"><block type=\"controls_if\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\"><field name=\"OP\">EQ</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_modulo\"><value name=\"DIVIDEND\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"spI`B?ML_K@WF]ppXSF:\">i</field></block></value><value name=\"DIVISOR\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_modulo\"><value name=\"DIVIDEND\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"y$KNNzp3?jgee^^w?~4g\">j</field></block></value><value name=\"DIVISOR\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value></block></value></block></value><statement name=\"DO0\"><block type=\"Image_setPixel\"><value name=\"picture\"><block type=\"variables_get\"><field name=\"VAR\" id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</field></block></value><value name=\"x\"><block type=\"variables_get\"><field name=\"VAR\" id=\"spI`B?ML_K@WF]ppXSF:\">i</field></block></value><value name=\"y\"><block type=\"variables_get\"><field name=\"VAR\" id=\"y$KNNzp3?jgee^^w?~4g\">j</field></block></value><value name=\"c\"><shadow type=\"colorindexpicker\"><field name=\"index\">1</field></shadow></value></block></statement><statement name=\"ELSE\"><block type=\"Image_setPixel\"><value name=\"picture\"><block type=\"variables_get\"><field name=\"VAR\" id=\"kKzE6BE@Ev2e4r{kl;zc\">myImage</field></block></value><value name=\"x\"><block type=\"variables_get\"><field name=\"VAR\" id=\"spI`B?ML_K@WF]ppXSF:\">i</field></block></value><value name=\"y\"><block type=\"variables_get\"><field name=\"VAR\" id=\"y$KNNzp3?jgee^^w?~4g\">j</field></block></value><value name=\"c\"><shadow type=\"colorindexpicker\"><field name=\"index\">15</field></shadow></value></block></statement></block></statement></block></statement><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Simplex noise test...</field></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let simpGen = new noise.OpenSimplexNoise2D();\" numlines=\"1\" declaredvars=\"simpGen\"></mutation><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">160</field></shadow></value><statement name=\"DO\"><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">120</field></shadow></value></block></statement></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>","main.ts":"let myImage = image.create(160, 120)\nscene.setBackgroundImage(myImage)\nfor (let i = 0; i <= 159; i++) {\n    for (let j = 0; j <= 119; j++) {\n        if (i % 2 == j % 2) {\n            myImage.setPixel(i, j, 1)\n        } else {\n            myImage.setPixel(i, j, 15)\n        }\n    }\n}\n\nlet palBufGray: Buffer = hex`000000111111222222333333444444555555666666777777888888999999aaaaaabbbbbbccccccddddddeeeeeeffffff`\nlet palBufColr: Buffer = hex`0000000000FF0033FF00FFFF00BBAAFFFF44FFCC1100CC0000FF0000AA66888888999999aaaaaabbbbbbddddddffffff`\nlet palBufDebg: Buffer = hex`0000000000FF0033FF00FFFF00BBAAFFFF44FFCC1100CC0000FF0000AA66888888999999ffaa00ff00ffff0000ffffff`\nimage.setPalette(palBufGray)\n\nconst scalingFactor = 1 / (4 / 30);\n\nlet offsetX = 0;\nlet offsetY = 0;\n\nconst ajdFactorA: number = 0.12;\nconst ajdFactorM: number = 1 - Math.SQRT1_2 - ajdFactorA;\nconst ajdFactorR: number = 1 / (Math.SQRT2 - 1 + (2 * ajdFactorA));\nconst maxVal = 0.04;\nlet freq = 1 / (160 * 2);\nfunction redrawBackground() {\n    for (let x = 0; x < 160; x++) {\n        for (let y = 0; y < 120; y++) {\n            // let val = simpGen.noise(i * zoom, j * zoom);\n            // val *= scalingFactor;\n            // val += 1;\n            // val /= 2;\n            // val *= 15;\n            // val = Math.ceil(val);\n\n            // val = (val + maxVal) / (2 * maxVal);\n            // val = (val - ajdFactorM) * ajdFactorR;\n            // val = Math.max(Math.min(Math.round(val * 14) + 1, 15), 1);\n\n\n            let val = simpGen.noise((x * zoom + offsetX) / 160, (y * zoom + offsetY) / 160);\n            // let val = perGen.noise(x * zoom / 160, y * zoom / 160);\n\n            val = (val + 1) / 2;\n            val = Math.round(val * 14) + 1;\n\n            myImage.setPixel(x, y, val)\n        }\n    }\n}\n\npause(500)\ngame.splash(\"Simplex noise test...\")\n\nlet simpGen = new noise.OpenSimplexNoise2D();\nlet perGen = new noise.PerlinNoise2D(noise.interpolateQuint2);\nlet zoom = 1;\nredrawBackground();\n\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, function () {\n    zoom *= 1.2;\n    redrawBackground();\n})\ncontroller.B.onEvent(ControllerButtonEvent.Pressed, function () {\n    zoom /= 1.2;\n    redrawBackground();\n})\n\nlet max = -9999;\nlet min = 9999;\nfor (let i = 0; i < 100000; i++) {\n    let val = simpGen.noise(i / 1000, i / 1000);\n    if (val > max)\n        max = val\n    if (val < min)\n        min = val\n}\ngame.splash(\"min: \" + (min), \"max: \" + (max));\n\nconst movspd = 10;\ncontroller.left.onEvent(ControllerButtonEvent.Pressed, function () {\n    offsetX -= zoom * movspd;\n    redrawBackground();\n})\ncontroller.right.onEvent(ControllerButtonEvent.Pressed, function () {\n    offsetX += zoom * movspd;\n    redrawBackground();\n})\ncontroller.up.onEvent(ControllerButtonEvent.Pressed, function () {\n    offsetY -= zoom * movspd;\n    redrawBackground();\n})\ncontroller.down.onEvent(ControllerButtonEvent.Pressed, function () {\n    offsetY += zoom * movspd;\n    redrawBackground();\n})","README.md":" ","assets.json":"","noise.ts":"namespace noise {\n    // make a size 512 table from copying the permutation table twice\n    export function copyPermutationTable(): number[] {\n        let table: number[] = [];\n        for (let i = 0; i < 512; i++) {\n            table.push(PERMUTATION_TABLE[i & 255]);\n        }\n        return table;\n    }\n\n    //#FIXME test this more, but it seems to work.\n    export function generatePermutationTable(seed?: number): number[] {\n        // set up random number gen \n        let rand = new Math.FastRandom(seed);\n\n        // copy table\n        let table: number[] = copyPermutationTable();\n\n        // seed of 0 means original permutation table\n        if (!seed || seed == 0)\n            return table;\n\n        // Fisher-Yates shuffle the first half of the table\n        let index = 255;\n        for (let i = 0; i < 256; i++) {\n            // gen random index then swap\n            let swapIndex = rand.randomRange(0, index);\n            let temp = table[swapIndex];\n            table[swapIndex] = table[index];\n            table[index] = temp;\n            index--;\n        }\n\n        // copy the second half of the table\n        for (let i = 256; i < 512; i++) {\n            table[i] = table[i - 255];\n        }\n\n        return table;\n    }\n\n    export interface NoiseGenerator2D {\n        noise(x: number, y: number): number;\n    }\n\n    // mysterious 2d hash function. little performance effect.\n    const m = 0x5bd1e995;\n    export function hash2(x: number, y: number, seed: number) {\n        let hash = seed;\n\n        // process first vector element\n        let k = x;\n        k *= m;\n        k ^= k >> 24;\n        k *= m;\n        hash *= m;\n        hash ^= k;\n\n        // process second vector element\n        k = y;\n        k *= m;\n        k ^= k >> 24;\n        k *= m;\n        hash *= m;\n        hash ^= k;\n\n        // some final mixing\n        hash ^= hash >> 13;\n        hash *= m;\n        hash ^= hash >> 15;\n\n        return hash;\n    }\n\n    // skip the middle man and return the dot product of offset, since gradient's are known\n    export function gradientDot(offsetX: number, offsetY: number, val: number): number {\n        let mag = Math.sqrt((offsetX * offsetX) + (offsetY * offsetY) + 0.01) * Math.SQRT2;\n        // let mag = Math.sqrt((offsetX * offsetX) + (offsetY * offsetY)) * Math.SQRT2;\n        switch (val & 3) {\n            case 0:\n                return (offsetX + offsetY) / mag;\n            case 1:\n                return (-offsetX + offsetY) / mag;\n            case 2:\n                return (offsetX - offsetY) / mag;\n            case 3:\n                return (-offsetX - offsetY) / mag;\n        }\n\n        throw \"broke, never go here (gradientDot)\"\n    }\n\n    // 1d smooth quintic interpolation. linear saves about 10ms.\n    export function interpolateQuint1(a0: number, a1: number, w: number): number {\n        // quintic. 6t^5 - 15t^4 + 10t^3 \n        return (a1 - a0) * (((w * 6) - 15) * w + 10) * w * w * w + a0;\n    }\n\n    // quintic interpolation of 4 corners. large performance effect.\n    export function interpolateQuint2(a0: number, a1: number, a2: number, a3: number, sx: number, sy: number): number {\n        // slightly faster to reimplement rather than call the 1D function.\n        const mult_sx = (((sx * 6) - 15) * sx + 10) * sx * sx * sx;\n        const i0 = (a1 - a0) * mult_sx + a0;\n        const i1 = (a3 - a2) * mult_sx + a2;\n\n        return (i1 - i0) * (((sy * 6) - 15) * sy + 10) * sy * sy * sy + i0;\n    }\n\n    export function interpolateCubic1(a0: number, a1: number, t: number): number {\n        // cubic. 3t^2 - 2t^3\n        return (a1 - a0) * (3 - (2 * t)) * t * t + a0;\n    }\n    export function interpolateCubic2(a0: number, a1: number, a2: number, a3: number, tx: number, ty: number): number {\n        const mult_tx = (3 - (2 * tx)) * tx * tx;\n        const i0 = (a1 - a0) * mult_tx + a0;\n        const i1 = (a1 - a0) * mult_tx + a0;\n        return (i1 - i0) * (3 - (2 * ty)) * ty * ty + i0;\n    }\n\n    // 1d linear interpolation. \n    export function interpolateLin1(a0: number, a1: number, t: number): number {\n        return a0 + t * (a1 - a0);\n    }\n\n    // linear interpolation of 4 corners. large performance effect.\n    export function interpolateLin2(a0: number, a1: number, a2: number, a3: number, tx: number, ty: number): number {\n        let i0 = a0 + tx * (a1 - a0);\n        let i1 = a2 + tx * (a3 - a2);\n        return i0 + ty * (i1 - i0);\n    }\n\n    // clamps a number between min and max\n    export function clamp(val: number, min: number, max: number): number {\n        return Math.max(min, Math.min(val, max));\n    }\n\n    // clamps between -1 and 1\n    export function clampNoise(noise: number): number {\n        return Math.max(-1, Math.min(noise, 1));\n    }\n\n}","noiseConstants.ts":"// Types and constants for different noise algorithms\nnamespace noise {\n    export type NoiseFunction1D = (seed: number, x: number) => number; // #UNUSED\n    export type NoiseFunction2D = (seed: number, x: number, y: number) => number;\n    export type NoiseFunction3D = (seed: number, x: number, y: number, z: number) => number; // #UNUSED\n    export type NoiseFunction4D = (seed: number, w: number, x: number, y: number, z: number) => number; // #UNUSED\n\n    export type InterpolationFunction1D = (a0: number, a1: number, t: number) => number;\n    export type InterpolationFunction2D = (a0: number, a1: number, a2: number, a3: number, tx: number, ty: number) => number;\n\n    export const PERMUTATION_TABLE: number[] = [\n        151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,\n        140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148,\n        247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32,\n        57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175,\n        74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122,\n        60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54,\n        65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169,\n        200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64,\n        52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212,\n        207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213,\n        119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n        129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104,\n        218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241,\n        81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157,\n        184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93,\n        222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n    ];\n\n    export const SKEW_2D: number = 0.5 * (Math.sqrt(3.0) - 1.0);\n    export const UNSKEW_2D: number = (3.0 - Math.sqrt(3.0)) / 6.0;\n\n    export const GRADS_2D: number[] = [\n        1, 1,\n        -1, 1,\n        1, -1,\n        -1, -1,\n        1, 0,\n        -1, 0,\n        1, 0,\n        -1, 0,\n        0, 1,\n        0, -1,\n        0, 1,\n        0, -1\n    ]\n}","opensimplex.ts":"namespace noise {\n    /**\n     * an implementation of open simplex noise. \n     * resources:\n     *      http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf (dead but on waybackmachine)\n     *      http://weber.itn.liu.se/~stegu/simplexnoise/SimplexNoise.java (dead but on waybackmachine)\n     */\n    export class OpenSimplexNoise2D implements NoiseGenerator2D {\n        private permutationTable: number[];\n        private permutationTableMod12: number[];\n        constructor(seed?: number) {\n            this.permutationTable = generatePermutationTable(seed);\n            this.regeneratePermutationTableMod12();\n        }\n\n        private regeneratePermutationTableMod12() {\n            this.permutationTableMod12 = [];\n            for (let i = 0; i < 512; i++) {\n                this.permutationTableMod12.push(this.permutationTable[i] % 12);\n            }\n        }\n\n        public noise(x: number, y: number): number {\n            let n0: number, n1: number, n2: number; // Noise contributions from the three corners\n            // Skew the input space to determine which simplex cell we're in\n            let s: number = (x + y) * SKEW_2D; // Hairy factor for 2D\n            let i: number = Math.floor(x + s);\n            let j: number = Math.floor(y + s);\n            let t: number = (i + j) * UNSKEW_2D;\n            let X0: number = i - t; // Unskew the cell origin back to (x,y) space\n            let Y0: number = j - t;\n            let x0: number = x - X0; // The x,y distances from the cell origin\n            let y0: number = y - Y0;\n            // For the 2D case, the simplex shape is an equilateral triangle.\n            // Determine which simplex we are in.\n            let i1: number, j1: number; // Offsets for second (middle) corner of simplex in (i,j) coords\n            if (x0 > y0) { i1 = 1; j1 = 0; } // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n            else { i1 = 0; j1 = 1; }      // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n            // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n            // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n            // c = (3-sqrt(3))/6\n            let x1: number = x0 - i1 + UNSKEW_2D; // Offsets for middle corner in (x,y) unskewed coords\n            let y1: number = y0 - j1 + UNSKEW_2D;\n            let x2: number = x0 - 1.0 + 2.0 * UNSKEW_2D; // Offsets for last corner in (x,y) unskewed coords\n            let y2: number = y0 - 1.0 + 2.0 * UNSKEW_2D;\n            // Work out the hashed gradient indices of the three simplex corners\n            let ii: number = i & 255;\n            let jj: number = j & 255;\n            let gi0: number = this.permutationTableMod12[ii + this.permutationTable[jj]];\n            let gi1: number = this.permutationTableMod12[ii + i1 + this.permutationTable[jj + j1]];\n            let gi2: number = this.permutationTableMod12[ii + 1 + this.permutationTable[jj + 1]];\n            // Calculate the contribution from the three corners\n            let t0: number = 0.5 - x0 * x0 - y0 * y0;\n            if (t0 < 0) n0 = 0.0;\n            else {\n                t0 *= t0;\n                n0 = t0 * t0 * this.gradDot(gi0, x0, y0);\n            }\n            let t1: number = 0.5 - x1 * x1 - y1 * y1;\n            if (t1 < 0) n1 = 0.0;\n            else {\n                t1 *= t1;\n                n1 = t1 * t1 * this.gradDot(gi1, x1, y1);\n            }\n            let t2: number = 0.5 - x2 * x2 - y2 * y2;\n            if (t2 < 0) n2 = 0.0;\n            else {\n                t2 *= t2;\n                n2 = t2 * t2 * this.gradDot(gi2, x2, y2);\n            }\n            // Add contributions from each corner to get the final noise value.\n            // The result is scaled to return values in the interval [-1,1].\n            return 70.0 * (n0 + n1 + n2);\n        }\n\n        private gradDot(gi: number, x: number, y: number): number {\n            let ind = gi * 2;\n            return GRADS_2D[ind] * x + GRADS_2D[ind + 1] * y;\n        }\n    }\n}\n","perlin.ts":"namespace noise {\n    /**\n     * an implementation of perlin noise. \n     * resources:\n     *      https://rtouti.github.io/graphics/perlin-noise-algorithm\n     *      https://en.wikipedia.org/wiki/Perlin_noise\n     */\n    export class PerlinNoise2D implements NoiseGenerator2D {\n        private interpolationFunction: InterpolationFunction2D;\n        private permutationTable: number[];\n        private seed: number;\n        constructor(interpolationFunction: InterpolationFunction2D, seed?: number) {\n            this.reseed(seed);\n            this.interpolationFunction = interpolationFunction;\n        }\n\n        public noise(x: number, y: number): number {\n            let cornerX = Math.floor(x);\n            let cornerY = Math.floor(y);\n            let offsetX = x - cornerX;\n            let offsetY = y - cornerY;\n\n            // const hX = Math.floor(x) % 256;\n            // const hY = Math.floor(y) % 256;\n\n            const hX = Math.floor(x) & 255;\n            const hY = Math.floor(y) & 255;\n\n            let v1: number = gradientDot(offsetX - 0, offsetY - 0, this.permutationTable[this.permutationTable[hX + 0] + hY + 0]);\n            let v2: number = gradientDot(offsetX - 1, offsetY - 0, this.permutationTable[this.permutationTable[hX + 1] + hY + 0]);\n            let v3: number = gradientDot(offsetX - 0, offsetY - 1, this.permutationTable[this.permutationTable[hX + 0] + hY + 1]);\n            let v4: number = gradientDot(offsetX - 1, offsetY - 1, this.permutationTable[this.permutationTable[hX + 1] + hY + 1]);\n\n\n            // let v1 = -1;\n            // let v2 = -0.25;\n            // let v3 = 0.25;\n            // let v4 = 1;\n\n            return this.interpolationFunction(v1, v2, v3, v4, offsetX, offsetY);\n        }\n\n        public reseed(seed?: number) {\n            if (!seed || seed == 0) {\n                this.seed = 0;\n                this.permutationTable = copyPermutationTable();\n                return;\n            }\n\n            this.seed = seed;\n            this.permutationTable = generatePermutationTable(seed);\n        }\n    }\n}\n","pxt.json":"{\n    \"name\": \"simplexTest\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"noise.ts\",\n        \"noiseConstants.ts\",\n        \"opensimplex.ts\",\n        \"perlin.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v2.0.40\",\n        \"tag\": \"v2.0.40\",\n        \"commits\": \"https://github.com/microsoft/pxt-arcade/commits/e365009949b9c899fc4c9914e30e362bd22a209b\",\n        \"target\": \"2.0.40\",\n        \"pxt\": \"11.3.48\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1743053828149}